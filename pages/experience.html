<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Expérience</title>
    <link rel="stylesheet" href="/style/style.css" />
    <style>
        #timeline { position:relative; margin:1rem 0 2rem; padding-left:1rem; border-left:2px solid #e5e7eb; }
        .timeline-item { position:relative; margin:1rem 0 1.5rem; padding-left:1rem; }
        .timeline-item::before { content:""; position:absolute; left:-6px; top:.2rem; width:10px; height:10px; border-radius:9999px; background:#111827; }
        .timeline-heading { font-weight:600; }
        .timeline-meta { font-size:.9rem; color:#6b7280; }
        .chips { list-style:none; padding:0; display:flex; gap:.5rem; flex-wrap:wrap; }
        .chips li { padding:.35rem .6rem; border:1px solid #e5e7eb; border-radius:9999px; }

        /* Layout polish */
        .exp-wrap { max-width: 980px; margin: 0 auto; padding: 1rem; }
        .exp-header { display:flex; align-items:center; justify-content:space-between; gap:1rem; }
        .view-toggle { display:flex; gap:.5rem; }
        .view-toggle button{
        border:1px solid #e5e7eb; background:#fff; padding:.45rem .8rem; border-radius:9999px;
        font-weight:600; cursor:pointer; transition:all .15s ease;
        }
        .view-toggle button.active{ background:#111827; color:#fff; border-color:#111827; }

        /* Better list timeline */
        .timeline-list{ position:relative; margin:1.25rem 0 2rem; padding-left:1.25rem; border-left:2px solid #e5e7eb; }
        .tl-item{ position:relative; margin:1rem 0 1.4rem; padding-left:1rem; }
        .tl-item::before{ content:""; position:absolute; left:-7px; top:.45rem; width:12px; height:12px; border-radius:999px; background:#111827; box-shadow:0 0 0 4px #fff; }
        .tl-heading{ font-weight:700; }
        .tl-meta{ font-size:.9rem; color:#6b7280; margin-top:.15rem; }
        .tl-notes{ margin-top:.35rem; line-height:1.4; }

        /* Chips */
        .chips{ list-style:none; padding:0; display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.75rem; }
        .chips li{ padding:.35rem .6rem; border:1px solid #e5e7eb; border-radius:9999px; background:#fff; }

        /* Gantt */
        .gantt{ margin-top:1rem; }
        .gantt-legend{ display:flex; align-items:center; gap:.75rem; font-size:.9rem; color:#374151; margin-bottom:.5rem; }
        .gantt-legend .dot{ width:10px; height:10px; border-radius:9999px; display:inline-block; }
        .gantt-legend .past{ background:#9CA3AF; }
        .gantt-legend .present{ background:#111827; }

        .gantt-scroller{
        overflow:auto; border:1px solid #e5e7eb; border-radius:12px; background:#fafafa; 
        padding: 1rem; max-height:520px;
        }

        /* Legend colours */
        .key-full    { background:#2563eb; } /* blue */
        .key-intern  { background:#ef4444; } /* red */
        .key-current { background:#10b981; } /* green */

        /* Gantt axes & labels (SVG text inherits) */
        svg text{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; fill:#374151; font-size:12.5px; }
        
        /* Bubble map */
        .bubble-wrap{
        margin-top:1rem;
        border:1px solid #e5e7eb;
        border-radius:14px;
        background:#fafafa;
        padding:.5rem;
        overflow:hidden;
        }
        /* Better label contrast */
        .bubble-label, .bubble-sub {
        paint-order: stroke fill;          /* draw stroke first so text stays crisp */
        stroke: #ffffff;
        stroke-width: 2px;                 /* thin outline improves contrast on colors */
        }

        @media (max-width: 640px){
        .bubble-svg{ height: 360px; }      /* a little shorter on narrow screens */
        }
        .bubble-node{ cursor:pointer; transition:opacity .15s ease; }
        .bubble-node:hover{ opacity:.9; }
        .bubble-node.selected circle { stroke:#111827; stroke-width:3; }
        .highlight-row { animation: rowFlash 1.2s ease; }
        @keyframes rowFlash { 0%{opacity:.4} 100%{opacity:1} }
    </style>
</head>
<body>
  <header>
    <h1>Mon Blog</h1>
    <nav>
      <a href="/index.html">Accueil</a>
      <a href="/pages/daily_blog.html">Mon blog quotidien</a>
      <a href="/pages/experience.html">Expérience</a>
      <a href="/pages/education.html">Éducation</a>
      <a href="/pages/about.html">À propos</a>
      <a href="/pages/contact.html">Contact</a>
    </nav>
  </header>

  <main>
    <section class="exp-wrap">
        <div class="exp-header">
        <h2>Expérience</h2>
        <div class="view-toggle" role="tablist" aria-label="Type d'affichage">
            <button id="btn-list" class="active" role="tab" aria-selected="true">Liste</button>
            <button id="btn-gantt" role="tab" aria-selected="false">Gantt</button>
        </div>
        </div>

        <!-- List timeline -->
        <div id="timeline" class="timeline-list"></div>

        <!-- Gantt timeline -->
        <div id="gantt" class="gantt" hidden>
        <div class="gantt-legend">
            <span class="dot key-full"></span><b>Plein temps</b>
            <span class="dot key-intern"></span><b>Stage</b>
            <span class="dot key-current"></span><b>En cours</b>
        </div>
        <div class="gantt-scroller">
            <svg id="ganttSvg" width="100%" height="100" role="img" aria-label="Gantt des expériences"></svg>
        </div>
        </div>

        <h3>Entreprises</h3>
        <ul id="businesses" class="chips"></ul>
        <div id="bubblemap" class="bubble-wrap" aria-label="Carte à bulles des entreprises"></div>
    </section>
    </main>

    <script>
    // French month labels
    const MOIS_FR = ["janv.","févr.","mars","avr.","mai","juin","juil.","août","sept.","oct.","nov.","déc."];

    function fmtMonthYear(dStr){
        const d = new Date(dStr);
        return `${MOIS_FR[d.getMonth()]} ${d.getFullYear()}`;
    }
    function fmtRangePrecise(startISO, endISO){
        return `${fmtMonthYear(startISO)} — ${endISO ? fmtMonthYear(endISO) : "Présent"}`;
    }
    function monthsBetween(aISO, bISO){
        const a = new Date(aISO), b = new Date(bISO ?? new Date());
        return (b.getFullYear()-a.getFullYear())*12 + (b.getMonth()-a.getMonth());
    }
    function fmtDuration(startISO, endISO){
        const m = monthsBetween(startISO, endISO);
        const y = Math.floor(m/12), r = m%12;
        if (y && r) return `${y} ${y>1?"ans":"an"} ${r} mois`;
        if (y)       return `${y} ${y>1?"ans":"an"}`;
        return `${m} mois`;
    }

    // Larger number = larger bubble (radius in pixels)
    const PRESTIGE = {
    "Google": 74,
    "Microsoft": 66,
    "UCL": 54,
    "Capgemini": 48,
    "McMaster University": 44,
    "GeeksforGeeks": 40,
    "Quora": 38,
    "Unbounded Future": 36,
    "Geologix": 34
    };
    const DEFAULT_RADIUS = 34;

    // Compute dominant type per org
    function orgDominantType(items, org){
    const counts = { full:0, intern:0, current:0 };
    items.filter(i=>i.org===org).forEach(it => counts[getExpType(it)]++);
    // tie-breaker order: current > full > intern (pick what you prefer)
    if (counts.current >= counts.full && counts.current >= counts.intern) return 'current';
    if (counts.full    >= counts.intern) return 'full';
    return 'intern';
    }

    // map prestige -> radius (if number provided use as-is, else default)
    function radiusFor(name){
        const base = PRESTIGE[name] || DEFAULT_RADIUS;
        // scale by viewport so layout stays balanced across widths
        const wrap = document.getElementById('bubblemap');
        const w = (wrap && wrap.clientWidth) ? wrap.clientWidth : 980;
        const scale = clamp(w / 980, 0.8, 1.25);   // tweak range to taste
        return clamp(Math.round(base * scale), 26, 92); // min 26px, max 92px
    }

    // Clamp helper
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    // Estimate how many chars fit on one line inside the circle
    function charsThatFit(r, fontPx){
    // rough width estimate per char ~0.6em, circle text area ~ 1.8 * r
    const approxWidth = r * 1.8;
    return Math.max(4, Math.floor(approxWidth / (fontPx * 0.62)));
    }

    // Split into 1–2 lines if needed
    function wrapTwoLines(text, maxPerLine){
        if (text.length <= maxPerLine) return [text];
        // try two lines balanced
        const words = text.split(' ');
        if (words.length === 1) {
            return [text.slice(0, maxPerLine), text.slice(maxPerLine)];
        }
        let line1 = '', line2 = '';
        for (const w of words){
            if ((line1 + (line1? ' ':'') + w).length <= maxPerLine) {
            line1 += (line1? ' ':'') + w;
            } else {
            line2 += (line2? ' ':'') + w;
            }
        }
        if (!line2) return [line1];              // fell back to one line
        return [line1, line2];
    }

    // Truncate with ellipsis if still too long
    function ellipsis(s, max){
        return s.length <= max ? s : s.slice(0, Math.max(0, max-1)) + '…';
    }

    function renderBubbleMap(items){
    const wrap = document.getElementById('bubblemap');
    wrap.innerHTML = "";
    const w = wrap.clientWidth || 960, h = 420, cx = w/2, cy = h/2;

    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', h);
    svg.classList.add('bubble-svg');
    wrap.appendChild(svg);

    // nodes
    const orgs = [...new Set(items.map(i => i.org))];
    const nodes = orgs.map(name => {
        const r = radiusFor(name);
        const firstRole = (items.find(i=>i.org===name) || {}).role || "";
        const kind = orgDominantType(items, name);
        return { name, role:firstRole, r, kind, x:0, y:0, vx:0, vy:0 };
    });

    // initial circle
    const ringR = Math.min(w,h)*0.33;
    nodes.forEach((n,i)=>{ const t=(i/nodes.length)*Math.PI*2; n.x=cx+ringR*Math.cos(t); n.y=cy+ringR*Math.sin(t); });

    // tiny force sim
    const steps = 260;
    for(let s=0;s<steps;s++){
        nodes.forEach(n=>{ n.vx+=(cx-n.x)*0.0025; n.vy+=(cy-n.y)*0.0025; });
        for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
            const a=nodes[i], b=nodes[j];
            let dx=b.x-a.x, dy=b.y-a.y, d2=dx*dx+dy*dy;
            const minD=a.r+b.r+10; if(!d2){dx=0.01;dy=0.01;d2=dx*dx+dy*dy;}
            const d=Math.sqrt(d2);
            if(d<minD){
            const push=(minD-d)*0.5, ux=dx/d, uy=dy/d;
            a.vx-=ux*push*0.02; a.vy-=uy*push*0.02;
            b.vx+=ux*push*0.02; b.vy+=uy*push*0.02;
            }
        }
        }
        nodes.forEach(n=>{
        n.vx*=0.92; n.vy*=0.92; n.x+=n.vx; n.y+=n.vy;
        n.x=Math.max(n.r+8,Math.min(w-n.r-8,n.x));
        n.y=Math.max(n.r+8,Math.min(h-n.r-8,n.y));
        });
    }

    // draw
    nodes.forEach(n=>{
        // group for one bubble
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.classList.add('bubble-node');
        g.setAttribute('transform', `translate(${n.x},${n.y})`);
        svg.appendChild(g);

        // circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('r', n.r);
        circle.setAttribute('fill', colourFor(n.kind));
        circle.setAttribute('stroke', '#ffffff');
        circle.setAttribute('stroke-width', '2');
        g.appendChild(circle);

        // tooltip
        const title = document.createElementNS('http://www.w3.org/2000/svg','title');
        title.textContent = `${n.name}\n${n.role}`;
        g.appendChild(title);

        // ----- name label (auto size + wrap) -----
        const nameFs = clamp(Math.round(n.r * 0.34), 11, 18);
        const maxChars = charsThatFit(n.r, nameFs);
        const lines = wrapTwoLines(n.name, maxChars);

        if (lines.length === 1){
            const label = document.createElementNS('http://www.w3.org/2000/svg','text');
            label.setAttribute('text-anchor','middle');
            label.setAttribute('y', 2);
            label.setAttribute('class','bubble-label');
            label.setAttribute('font-size', nameFs);
            label.textContent = ellipsis(lines[0], maxChars);
            g.appendChild(label);
        } else {
            const label = document.createElementNS('http://www.w3.org/2000/svg','text');
            label.setAttribute('text-anchor','middle');
            label.setAttribute('class','bubble-label');
            label.setAttribute('font-size', nameFs);
            const t1 = document.createElementNS('http://www.w3.org/2000/svg','tspan');
            t1.setAttribute('x', 0);
            t1.setAttribute('dy', -2);
            t1.textContent = ellipsis(lines[0], maxChars);
            const t2 = document.createElementNS('http://www.w3.org/2000/svg','tspan');
            t2.setAttribute('x', 0);
            t2.setAttribute('dy', nameFs + 2);
            t2.textContent = ellipsis(lines[1], maxChars);
            label.appendChild(t1); label.appendChild(t2);
            g.appendChild(label);
        }

        // ----- role label (show only if there is room) -----
        if (n.role && n.r >= 40){
            const roleFs = clamp(Math.round(n.r * 0.24), 10, 13);
            const maxRole = Math.max(8, Math.floor((n.r * 1.7) / (roleFs * 0.62)));
            const sub = document.createElementNS('http://www.w3.org/2000/svg','text');
            sub.setAttribute('text-anchor','middle');
            sub.setAttribute('y', nameFs + 16);
            sub.setAttribute('class','bubble-sub');
            sub.setAttribute('font-size', roleFs);
            sub.textContent = ellipsis(n.role, maxRole);
            g.appendChild(sub);
        }

        // click highlight (optional; keeps your old behavior)
        g.addEventListener('click', ()=>{
            document.querySelectorAll('.bubble-node.selected').forEach(el=>el.classList.remove('selected'));
            g.classList.add('selected');

            const list = document.getElementById('timeline');
            const row = [...list.querySelectorAll('.tl-item')].find(el => el.textContent.includes(n.name));
            if (!elList.hidden && row){
            row.classList.add('highlight-row');
            row.scrollIntoView({behavior:'smooth', block:'center'});
            setTimeout(()=>row.classList.remove('highlight-row'), 1200);
            } else {
            document.querySelector('.gantt-scroller').scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    });

    // repack on resize (debounced)
    if (!renderBubbleMap._resizeBound){
        renderBubbleMap._resizeBound = true;
        let t;
        window.addEventListener('resize', ()=>{
        clearTimeout(t); t=setTimeout(()=>renderBubbleMap(items), 180);
        });
    }
    }

    function fmtRange(startISO, endISO) {
        const s = new Date(startISO).getFullYear();
        const e = endISO ? new Date(endISO).getFullYear() : "Présent";
        return `${s} - ${e}`;
    }

    async function loadTimeline() {
        const res = await fetch("/data/experiences.json");
        const items = (await res.json())
        .sort((a,b)=> new Date(b.start) - new Date(a.start));

        const wrap = document.getElementById("timeline");
        wrap.innerHTML = "";
        items.forEach(x => {
        const el = document.createElement("div");
        el.className = "timeline-item";
        el.innerHTML = `
            <div class="timeline-heading">${x.org} — ${x.role}</div>
            <div class="timeline-meta">${fmtRange(x.start, x.end)}</div>
            ${x.notes ? `<div>${x.notes}</div>` : ""}`;
        wrap.appendChild(el);
        });

        // derive businesses
        const set = new Set(items.map(i => i.org));
        const ul = document.getElementById("businesses");
        ul.innerHTML = "";
        [...set].forEach(n => { const li = document.createElement("li"); li.textContent = n; ul.appendChild(li); });
    }

    // --- helpers ---
    const parseDate = d => d ? new Date(d) : new Date(); // null -> now (present)
    const getYearStart = y => new Date(`${y}-01-01T00:00:00`);

    // --- view toggles ---
    const btnList = document.getElementById('btn-list');
    const btnGantt = document.getElementById('btn-gantt');
    const elList  = document.getElementById('timeline');
    const elGantt = document.getElementById('gantt');
    btnList.addEventListener('click', ()=>{ btnList.classList.add('active'); btnGantt.classList.remove('active'); elList.hidden=false; elGantt.hidden=true; });
    btnGantt.addEventListener('click', ()=>{ btnGantt.classList.add('active'); btnList.classList.remove('active'); elList.hidden=true; elGantt.hidden=false; });

    // --- load & render ---
    (async function init(){
        const res = await fetch('/data/experiences.json');
        const items = (await res.json()).sort((a,b)=> new Date(b.start) - new Date(a.start));

        renderList(items);
        renderBubbleMap(items);
        renderChips(items);
        renderGantt(items);
    })();

    function renderList(items){
        const wrap = document.getElementById('timeline');
        wrap.innerHTML = '';
        items.forEach(x=>{
        const d = document.createElement('div');
        d.className = 'tl-item';
        d.innerHTML = `
            <div class="tl-heading">${x.org} — ${x.role}</div>
            <div class="tl-meta">${fmtRangePrecise(x.start, x.end)} • ${fmtDuration(x.start, x.end)}</div>
            ${x.notes ? `<div class="tl-notes">${x.notes}</div>` : ""}`;
        wrap.appendChild(d);
        });
    }

    function renderChips(items){
        const set = new Set(items.map(i=>i.org));
        const ul = document.getElementById('businesses');
        ul.innerHTML = '';
        [...set].forEach(n => {
        const li = document.createElement('li');
        li.textContent = n;
        ul.appendChild(li);
        });
    }

    // Detect experience type from role + 'end' date
    function getExpType(it){
        if (!it.end) return 'current'; // ongoing
        const r = (it.role || '').toLowerCase();
        if (r.includes('intern')) return 'intern'; // Intern, Internship, etc.
        return 'full'; // everything else
    }

    function colourFor(type){
        switch(type){
            case 'current': return '#10b981'; // green
            case 'intern':  return '#ef4444'; // red
            default:        return '#2563eb'; // blue
        }
    }

    function renderGantt(items){
        // helpers
        const parseDate = d => d ? new Date(d) : new Date();
        const getYearStart = y => new Date(`${y}-01-01T00:00:00`);

        // 1) dynamic left column width
        const measureText = (txt, font='12px system-ui') => {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            ctx.font = font;
            return ctx.measureText(txt).width;
        };
        const labels = items.map(it => `${it.org} — ${it.role}`);
        const maxLabelPx = Math.max(...labels.map(t => measureText(t)));
        const leftPad = Math.max(160, 24 + Math.ceil(maxLabelPx)); // min 160

        // 2) date range
        const starts = items.map(i=>parseDate(i.start));
        const ends   = items.map(i=>parseDate(i.end));
        const minDate = new Date(Math.min(...starts.map(d=>d.getTime())));
        const maxDate = new Date(Math.max(...ends.map(d=>d.getTime())));
        const minYear = minDate.getFullYear();
        const maxYear = Math.max(maxDate.getFullYear(), new Date().getFullYear());

        // 3) svg size
        const rowH = 36, rowGap = 12, topPad = 40, rightPad = 24, bottomPad = 44;
        const rows = items.length;
        const pxPerYear = 180;
        const svgW = Math.max(800, (maxYear - minYear + 1) * pxPerYear + leftPad + rightPad);
        const svgH = topPad + rows*(rowH+rowGap) + bottomPad;

        const svg = document.getElementById('ganttSvg');
        svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);
        svg.setAttribute('height', svgH);

        // clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        // 4) scale
        const xScale = (date)=>{
            const t0 = getYearStart(minYear).getTime();
            const t1 = getYearStart(maxYear+1).getTime();
            const t  = new Date(date).getTime();
            return leftPad + (t - t0) / (t1 - t0) * (svgW - leftPad - rightPad);
        };

        // 5) grid: light monthly lines, bold yearly lines + year labels
        for (let y = minYear; y <= maxYear; y++){
            for (let m = 0; m < 12; m++){
                const x = xScale(new Date(y, m, 1));
                const line = document.createElementNS('http://www.w3.org/2000/svg','line');
                line.setAttribute('x1', x); line.setAttribute('x2', x);
                line.setAttribute('y1', topPad-8); line.setAttribute('y2', svgH-bottomPad+6);
                // January (year boundary) gets a darker line
                if (m === 0) {
                line.setAttribute('stroke', '#E5E7EB');
                line.setAttribute('stroke-width', 1.2);
                } else {
                line.setAttribute('stroke', '#EEF2F7'); // very light
                line.setAttribute('stroke-width', 1);
                }
                svg.appendChild(line);

                // Year label once per year (above the January line)
                if (m === 0){
                const tx = document.createElementNS('http://www.w3.org/2000/svg','text');
                tx.setAttribute('x', x + 4); tx.setAttribute('y', topPad-16);
                tx.textContent = y;
                svg.appendChild(tx);
                }
            }
        }


        // 6) rows & bars (NO duration text on bars)
        items.forEach((it, idx)=>{
            const y = topPad + idx*(rowH+rowGap);

            // left label
            const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
            lbl.setAttribute('x', 8);
            lbl.setAttribute('y', y + rowH*0.7);
            lbl.textContent = `${it.org} — ${it.role}`;
            svg.appendChild(lbl);

            // bar
            const startX = xScale(parseDate(it.start));
            const endX   = xScale(parseDate(it.end || new Date()));
            const w      = Math.max(8, endX - startX);

            const bar = document.createElementNS('http://www.w3.org/2000/svg','rect');
            bar.setAttribute('x', startX);
            bar.setAttribute('y', y + 6);
            bar.setAttribute('width', w);
            bar.setAttribute('height', rowH - 12);
            bar.setAttribute('rx', 8);
            bar.setAttribute('ry', 8);
            const kind = getExpType(it);
            bar.setAttribute('fill', colourFor(kind));
            // tooltip with dates on hover
            const tip = document.createElementNS('http://www.w3.org/2000/svg','title');
            tip.textContent = `${it.org} — ${it.role}\n${fmtRangePrecise(it.start, it.end)}  •  ${fmtDuration(it.start, it.end)}`;
            bar.appendChild(tip);
            svg.appendChild(bar);

            // (Removed the duration text entirely to keep bars clean)
        });
    }

    // loadTimeline();
    </script>
</body>
</html>